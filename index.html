<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>JavaScript by sumitnsit</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">JavaScript</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/sumitnsit/javascript" class="btn">View on GitHub</a>
      <a href="https://github.com/sumitnsit/javascript/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/sumitnsit/javascript/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>JavaScript is the first lambda language to go mainstream. Deep down, JavaScript has more in common with Lisp and Scheme than with Java.</p>

<p><code>JSLint</code>, a JavaScript parser that can analyze a JavaScript program and report on the bad parts that it contains. <code>JSLint</code> provides a degree of rigor that is generally lacking in JavaScript development. It can give you confidence that your programs contain only the good parts.</p>

<h3>
<a id="add-method" class="anchor" href="#add-method" aria-hidden="true"><span class="octicon octicon-link"></span></a>Add Method</h3>

<p>The following code adds a function called <code>newMethod</code> in the <code>Function</code> object. Which can be used to add more functions to the <code>Function</code> object, which will be applicable to all the functions.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-c1">Function</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">newMethod</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">name</span>, <span class="pl-smi">func</span>) {
  <span class="pl-v">this</span>.<span class="pl-c1">prototype</span>[name] <span class="pl-k">=</span> func;
  <span class="pl-k">return</span> <span class="pl-v">this</span>;
};</pre></div>

<h3>
<a id="numbers" class="anchor" href="#numbers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Numbers</h3>

<p>JavaScript has a single number type. Internally, it is represented as 64-bit floating point</p>

<p>The value <code>NaN</code> is a number value that is the result of an operation that cannot produce a normal result. <code>NaN</code> is not equal to any value, including itself. You can detect <code>NaN</code> with the <code>isNaN(number)</code> function.</p>

<h3>
<a id="strings" class="anchor" href="#strings" aria-hidden="true"><span class="octicon octicon-link"></span></a>Strings</h3>

<p>JavaScript was built at a time when Unicode was a 16-bit character set, so all characters in JavaScript are 16 bits wide.</p>

<p>Strings are immutable. The following statement returns <code>true</code></p>

<div class="highlight highlight-javascript"><pre><span class="pl-s"><span class="pl-pds">'</span>c<span class="pl-pds">'</span></span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>t<span class="pl-pds">'</span></span> <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">'</span>cat<span class="pl-pds">'</span></span></pre></div>

<h4>
<a id="falsy-values" class="anchor" href="#falsy-values" aria-hidden="true"><span class="octicon octicon-link"></span></a>falsy values</h4>

<ol>
<li><code>false</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li>The empty string ''</li>
<li>The number <code>0</code>
</li>
<li>The number <code>NaN</code>
</li>
</ol>

<h3>
<a id="for-in---loop" class="anchor" href="#for-in---loop" aria-hidden="true"><span class="octicon octicon-link"></span></a>for in - loop</h3>

<p>It is usually necessary to test object . hasOwnProperty( variable ) to determine whether the property name is truly a member of the object or was found instead on the prototype chain.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">for</span> (myvar <span class="pl-k">in</span> obj) {
  <span class="pl-k">if</span> (obj.<span class="pl-c1">hasOwnProperty</span>(myvar)) {

  }
}</pre></div>

<p>​
The values produced by typeof are <code>number</code> , <code>string</code> , <code>boolean</code> , <code>undefined</code> , <code>function</code> , and <code>object</code> . If the operand is an array or null , then the result is <code>object</code> , which is wrong.</p>

<h3>
<a id="objects" class="anchor" href="#objects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Objects</h3>

<p>The simple types of JavaScript are <code>numbers</code>, <code>strings</code>, <code>booleans</code> (<code>true</code> and <code>false</code>), <code>null</code> , and <code>undefined</code>. All other values are objects . <code>Numbers</code>, <code>strings</code>, and <code>booleans</code> are object-like in that they have methods, but they are immutable. Objects in JavaScript are mutable keyed collections.</p>

<p>A property's name can be any string, including the empty string.</p>

<p>Quotes are required around "first-name" , but are optional around first_name.</p>

<p>Values can be retrieved from an object by wrapping a string expression in a <code>[]</code> suffix. If the string expression is a string literal, and if it is a legal JavaScript name and not a reserved word, then the <code>.</code> notation can be used instead.</p>

<p>Attempting to retrieve values from undefined will throw a <code>TypeError</code> exception. This can be guarded against with the <code>&amp;&amp;</code> operator</p>

<div class="highlight highlight-javascript"><pre>
<span class="pl-k">var</span> value <span class="pl-k">=</span> flight.<span class="pl-c1">equipment</span> <span class="pl-k">&amp;&amp;</span> flight.<span class="pl-c1">equipment</span>.<span class="pl-c1">model</span></pre></div>

<p>Objects are passed around by reference. They are never copied.</p>

<h3>
<a id="prototype" class="anchor" href="#prototype" aria-hidden="true"><span class="octicon octicon-link"></span></a>Prototype</h3>

<p>Every object is linked to a prototype object from which it can inherit properties.</p>

<p>When you make a new object, you can select the object that should be its prototype. The mechanism that JavaScript provides to do this is messy and complex, but it can be significantly simplified.</p>

<p>This adds a create method to the Object function. It creates a new object that uses an old object as its prototype.</p>

<div class="highlight highlight-javascript"><pre>
<span class="pl-k">if</span> (<span class="pl-k">typeof</span> <span class="pl-c1">Object</span>.<span class="pl-c1">create</span> <span class="pl-k">!==</span> <span class="pl-s"><span class="pl-pds">'</span>function<span class="pl-pds">'</span></span>) {
  <span class="pl-c1">Object</span>.<span class="pl-en">create</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">o</span>) {
    <span class="pl-k">var</span> <span class="pl-en">F</span> <span class="pl-k">=</span> <span class="pl-k">function</span> () {
    };
    <span class="pl-c1">F</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> o;
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">F</span>();
  };
}

<span class="pl-k">var</span> another_stooge <span class="pl-k">=</span> <span class="pl-c1">Object</span>.<span class="pl-c1">create</span>(stooge);</pre></div>

<p>​When we make changes to an object, the object's prototype is not touched. The prototype link is used only in retrieval.</p>

<p>The prototype relationship is a dynamic relationship. If we add a new property to a prototype, that property will immediately be visible in all of the objects that are based on that prototype.</p>

<h3>
<a id="delegation" class="anchor" href="#delegation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Delegation</h3>

<p>If we try to retrieve a property value from an object, and if the object lacks the property name, then JavaScript attempts to retrieve the property value from the prototype object. And if that object is lacking the property, then it goes to its prototype, and so on until the process finally bottoms out with <code>Object.prototype</code>. If the desired property exists nowhere in the prototype chain, then the result is the <code>undefined</code> value. This is called delegation</p>

<p>the <code>hasOwnProperty</code> method, which returns <code>true</code> if the object has a particular property. The <code>hasOwnProperty</code> method does not look at the prototype chain.</p>

<h3>
<a id="enumeration" class="anchor" href="#enumeration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Enumeration</h3>

<p>The <code>for in</code> statement can loop over all of the property names in an object. The enumeration will include all of the properties including functions and prototype properties that you might not be interested in so it is necessary to filter out the values you don't want.</p>

<div class="highlight highlight-javascript"><pre>
<span class="pl-k">var</span> name;
<span class="pl-k">for</span> (name <span class="pl-k">in</span> another_stooge) {
  <span class="pl-k">if</span> (<span class="pl-k">typeof</span> another_stooge[name] <span class="pl-k">!==</span> <span class="pl-s"><span class="pl-pds">'</span>function<span class="pl-pds">'</span></span>) {
    <span class="pl-c1">document</span>.<span class="pl-c1">writeln</span>(name <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>: <span class="pl-pds">'</span></span> <span class="pl-k">+</span> another_stooge[name]);
  }
}</pre></div>

<p>There is no guarantee on the order of the names.</p>

<h3>
<a id="delete" class="anchor" href="#delete" aria-hidden="true"><span class="octicon octicon-link"></span></a>Delete</h3>

<p>The <code>delete</code> operator can be used to remove a property from an object. It will remove a property from the object if it has one. It will not touch any of the objects in the prototype linkage.</p>

<p>Removing a property from an object may allow a property from the prototype linkage to shine through:</p>

<h3>
<a id="global-abatement" class="anchor" href="#global-abatement" aria-hidden="true"><span class="octicon octicon-link"></span></a>Global Abatement</h3>

<p>One way to minimize the use of global variables is to create a single global variable for your application:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> <span class="pl-c1">MYAPP</span> <span class="pl-k">=</span> {

}</pre></div>

<p>By reducing your global footprint to a single name, you significantly reduce the chance of bad interactions with other applications, widgets, or libraries.</p>

<h2>
<a id="functions" class="anchor" href="#functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Functions</h2>

<p>Functions in JavaScript are objects. Objects are collections of name/value pairs having a hidden link to a prototype object.</p>

<p>Objects produced from object literals are linked to <code>Object.prototype</code> . Function objects are linked to <code>Function.prototype</code> (which is itself linked to <code>Object.prototype</code>). Every function is also created with two additional hidden properties: the function's context and the code that implements the function's behavior. Every function object is also created with a <code>prototype</code> property. Its value is an object with a constructor property whose value is the function. This is distinct from the hidden link to <code>Function.prototype</code>.</p>

<h3>
<a id="closure" class="anchor" href="#closure" aria-hidden="true"><span class="octicon octicon-link"></span></a>Closure</h3>

<p>Closures are an extension of the concept of scope. With closures, functions have access to variables that were available in the scope where the function was created.</p>

<p>Inner functions get access to the parameters and variables of the functions they are defined within. A more interesting case is when the inner function has a longer lifetime than its outer function. Avoid creating functions within a loop. It can be wasteful computationally,and it can cause confusion.</p>

<h3>
<a id="invocation" class="anchor" href="#invocation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Invocation</h3>

<p>There are four patterns of invocation in JavaScript: the method invocation pattern, the function invocation pattern, the constructor invocation pattern, and the apply invocation pattern.</p>

<p>In addition to the declared parameters, every function receives two additional parameters: <code>this</code> and <code>arguments</code>.</p>

<p>The <code>this</code> parameter is very important in object oriented programming, and its value is determined by the invocation pattern.</p>

<h4>
<a id="method-invocation-pattern" class="anchor" href="#method-invocation-pattern" aria-hidden="true"><span class="octicon octicon-link"></span></a>Method Invocation Pattern</h4>

<p>When a function is stored as a property of an object, we call it a method. When a method is invoked, this is bound to that object.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> myObject <span class="pl-k">=</span> {
  value<span class="pl-k">:</span> <span class="pl-c1">0</span>,
  <span class="pl-en">increment</span><span class="pl-k">:</span> <span class="pl-k">function</span> (<span class="pl-smi">inc</span>) {
    <span class="pl-v">this</span>.<span class="pl-c1">value</span> <span class="pl-k">+=</span> <span class="pl-k">typeof</span> inc <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">'</span>number<span class="pl-pds">'</span></span> <span class="pl-k">?</span> inc <span class="pl-k">:</span> <span class="pl-c1">1</span>;
  }
};
myObject.<span class="pl-c1">increment</span>();

<span class="pl-en">console</span><span class="pl-c1">.log</span>(myObject.<span class="pl-c1">value</span>);
<span class="pl-c">//Output is 1</span>
myObject.<span class="pl-c1">increment</span>(<span class="pl-c1">2</span>);
<span class="pl-en">console</span><span class="pl-c1">.log</span>(myObject.<span class="pl-c1">value</span>);
<span class="pl-c">//Output is 3</span></pre></div>

<h4>
<a id="function-invocation-pattern" class="anchor" href="#function-invocation-pattern" aria-hidden="true"><span class="octicon octicon-link"></span></a>Function Invocation Pattern</h4>

<p>When a function is not the property of an object, then it is invoked as a function.</p>

<p>When a function is invoked with this pattern, <code>this</code> is bound to the global object. Due to this the inner function's <code>this</code> variable points to global object rathar than to its outer function's object. Following is the workaround to solve this issue.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> myobj <span class="pl-k">=</span> {
  <span class="pl-en">getName</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){
    <span class="pl-k">var</span> that <span class="pl-k">=</span> <span class="pl-v">this</span>;
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-v">this</span>);
    <span class="pl-c">// prints myobj</span>
    <span class="pl-k">function</span> <span class="pl-en">inner</span>(){
      <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-v">this</span>);
      <span class="pl-c">// prints global object</span>
      <span class="pl-en">console</span><span class="pl-c1">.log</span>(that);
      <span class="pl-c">// prints myobj</span>
    }
    <span class="pl-c1">inner</span>();
  }
}</pre></div>

<h4>
<a id="constructor-invocation-pattern" class="anchor" href="#constructor-invocation-pattern" aria-hidden="true"><span class="octicon octicon-link"></span></a>Constructor Invocation Pattern</h4>

<p>When a function is invoked using new keyword then it returns an object. The returned object contains properties of function's prototype object, but when you query for hasOwnProperty() then it returns false for those proprty defind in the function's prototype.</p>

<p>Functions that are intended to be used with the <code>new</code> prefix are called constructors . By convention, they are kept in variables with a capitalized name.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> <span class="pl-en">Func</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){

}

Func.<span class="pl-c1">prototype</span> <span class="pl-c">// is an empty object, prints Func {}</span>

<span class="pl-k">var</span> obj <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Func</span>();

obj.<span class="pl-c1">prototype</span> <span class="pl-c">// Func.prototype is not linked to obj.prototype, prints undefined</span>

obj <span class="pl-c">// prints Func {}</span>
<span class="pl-c1">Func</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Sumit<span class="pl-pds">"</span></span>;
obj.<span class="pl-c1">name</span> <span class="pl-c">// prints "Sumit"</span>
obj.<span class="pl-c1">hasOwnProperty</span>(name) <span class="pl-c">// retuns false</span></pre></div>

<h4>
<a id="apply-invocation-pattern" class="anchor" href="#apply-invocation-pattern" aria-hidden="true"><span class="octicon octicon-link"></span></a>Apply Invocation Pattern</h4>

<p>The <code>apply</code> method lets us construct an array of arguments to use to invoke a function. It also lets us choose the value of <code>this</code>. The apply method takes two parameters. The first is the value that should be bound to <code>this</code>. The second is an array of parameters.</p>

<p>Suppose you already have a function defined in an object which uses object's property (using this) and input params to calculate something. Now, you want to reuse that method but you don't want to use that object's property but your object's property and also want to use your own input parameters.</p>

<p>Call <code>apply</code> function on that method by passing your own object which will be used as <code>this</code> and pass an array of arguments if required.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> obj <span class="pl-k">=</span> {
  val<span class="pl-k">:</span> <span class="pl-c1">5</span>,
  <span class="pl-en">add</span><span class="pl-k">:</span> <span class="pl-k">function</span>(<span class="pl-smi">input</span>){
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-c1">val</span> <span class="pl-k">+</span> input;
  }
}
<span class="pl-en">console</span><span class="pl-c1">.log</span>(obj.<span class="pl-c1">add</span>(<span class="pl-c1">10</span>));
<span class="pl-c">// prints 15</span>
<span class="pl-k">var</span> anotherObject <span class="pl-k">=</span> {
  val<span class="pl-k">:</span> <span class="pl-c1">10</span> 
}
<span class="pl-en">console</span><span class="pl-c1">.log</span>(obj.<span class="pl-c1">add</span>.<span class="pl-c1">apply</span>(anotherObject, [<span class="pl-c1">20</span>]));
<span class="pl-c">// prints 30</span></pre></div>

<h3>
<a id="argument" class="anchor" href="#argument" aria-hidden="true"><span class="octicon octicon-link"></span></a>Argument</h3>

<p>A bonus parameter that is available to functions when they are invoked is the arguments array.</p>

<p>Because of a design error, arguments is not really an <code>array</code>. It is an array-like object. arguments has a length property, but it lacks all of the array methods.</p>

<h3>
<a id="return" class="anchor" href="#return" aria-hidden="true"><span class="octicon octicon-link"></span></a>Return</h3>

<p>A function always returns a value. If the return value is not specified, then <code>undefined</code> is returned. If the function was invoked with the <code>new</code> prefix and the return value is not an object, then <code>this</code> (the new object) is returned instead.</p>

<h3>
<a id="exceptions" class="anchor" href="#exceptions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Exceptions</h3>

<p>A <code>try</code> statement has a single catch block that will catch all exceptions. If your handling depends on the type of the exception, then the exception handler will have to inspect the name to determine the type of the exception.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> <span class="pl-en">try_it</span> <span class="pl-k">=</span> <span class="pl-k">function</span> ( ) {
  <span class="pl-k">try</span> {
    <span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">"</span>seven<span class="pl-pds">"</span></span>);
  }
  <span class="pl-k">catch</span> (e) {
    <span class="pl-c1">document</span>.<span class="pl-c1">writeln</span>(e.<span class="pl-c1">name</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>: <span class="pl-pds">'</span></span> <span class="pl-k">+</span> e.<span class="pl-c1">message</span>);
  }
}</pre></div>

<h3>
<a id="augmenting-types" class="anchor" href="#augmenting-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Augmenting Types</h3>

<p>Augmenting means adding some usefull functions at top level e.g. adding getIntonly to <code>Number</code> or adding trim to <code>String</code></p>

<p>JavaScript allows the basic types of the language to be augmented. In JavaScript you can add methods to any object. Adding a method to <code>Object.prototype</code> makes that method available to all objects.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-c1">Function</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">method</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">name</span>, <span class="pl-smi">func</span>) {
  <span class="pl-v">this</span>.<span class="pl-c1">prototype</span>[name] <span class="pl-k">=</span> func;
  <span class="pl-k">return</span> <span class="pl-v">this</span>;
};</pre></div>

<p>​
By augmenting the basic types, we can make significant improvements to the expressiveness of the language. Because of the dynamic nature of JavaScript's prototypal inheritance, all values are immediately endowed with the new methods, even values that were created before the methods were created.</p>

<p>The prototypes of the basic types are public structures, so care must be taken when mixing libraries. One defensive technique is to add a method only if the method is known to be missing:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-c1">Function</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">method</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">name</span>, <span class="pl-smi">func</span>) {
  <span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-v">this</span>.<span class="pl-c1">prototype</span>[name]) {
    <span class="pl-v">this</span>.<span class="pl-c1">prototype</span>[name] <span class="pl-k">=</span> func;
    <span class="pl-k">return</span> <span class="pl-v">this</span>;
  }
};</pre></div>

<h3>
<a id="scope" class="anchor" href="#scope" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scope</h3>

<p>Unfortunately, JavaScript does not have block scope even though its block syntax suggests that it does. For example a variable declared inside 'if' control is accessible after the 'if' block.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> num <span class="pl-k">=</span> <span class="pl-c1">5</span>;
<span class="pl-k">if</span>(num <span class="pl-k">===</span> <span class="pl-c1">5</span>){
  <span class="pl-k">var</span> val <span class="pl-k">=</span> <span class="pl-c1">10</span>;
}
<span class="pl-en">console</span><span class="pl-c1">.log</span>(val);
<span class="pl-c">// prints 10</span></pre></div>

<p>​
In many modern languages, it is recommended that variables be declared as late as possible, at the first point of use. That turns out to be bad advice for JavaScript because it lacks block scope. So instead, it is best to declare all of the variables used in a function at the top of the function body.</p>

<h3>
<a id="module" class="anchor" href="#module" aria-hidden="true"><span class="octicon octicon-link"></span></a>Module</h3>

<p>We can use functions and closure to make modules. A module is a function or object that presents an interface but that hides its state and implementation. By using functions to produce modules, we can almost completely eliminate our use of global variables, thereby mitigating one of JavaScript's worst features.</p>

<p>Use of the module pattern can eliminate the use of global variables. It promotes information hiding and other good design practices. It is very effective in encapsulating applications and other singletons.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> Employee <span class="pl-k">=</span> (<span class="pl-k">function</span>(){
  <span class="pl-k">var</span> salary <span class="pl-k">=</span> <span class="pl-c1">2000</span>;
  <span class="pl-k">return</span> {
    <span class="pl-en">getSalary</span><span class="pl-k">:</span> <span class="pl-k">function</span>(){
      <span class="pl-k">return</span> salary;
    }
  }
}());

<span class="pl-en">console</span><span class="pl-c1">.log</span>(Employee.<span class="pl-c1">getSalary</span>()); <span class="pl-c">// prints 2000</span></pre></div>

<h3>
<a id="cascade" class="anchor" href="#cascade" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cascade</h3>

<p>Some methods do not have a return value. For example, it is typical for methods that set or change the state of an object to return nothing. If we have those methods return this instead of undefined , we can enable cascades. In a cascade, we can call many methods on the same object in sequence in a single statement.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-c1">getElement</span>(<span class="pl-s"><span class="pl-pds">'</span>myBoxDiv<span class="pl-pds">'</span></span>).<span class="pl-c1">move</span>(<span class="pl-c1">350</span>, <span class="pl-c1">150</span>).<span class="pl-c1">width</span>(<span class="pl-c1">100</span>).<span class="pl-c1">height</span>(<span class="pl-c1">100</span>).<span class="pl-c1">color</span>(<span class="pl-s"><span class="pl-pds">'</span>red<span class="pl-pds">'</span></span>);</pre></div>

<h3>
<a id="curry" class="anchor" href="#curry" aria-hidden="true"><span class="octicon octicon-link"></span></a>Curry</h3>

<p>Currying allows us to produce a new function by combining a function and an argument.</p>

<p>The curry method works by creating a closure that holds that original function and the arguments to curry. It returns a function that, when invoked, returns the result of calling that original function, passing it all of the arguments from the invocation of curry and the current invocation.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-c1">Function</span>.<span class="pl-c1">method</span>(<span class="pl-s"><span class="pl-pds">'</span>curry<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>() {
  <span class="pl-k">var</span> slice <span class="pl-k">=</span> <span class="pl-c1">Array</span>.<span class="pl-c1">prototype</span>.<span class="pl-c1">slice</span>;
  <span class="pl-k">var</span> args <span class="pl-k">=</span> slice.<span class="pl-c1">apply</span>(arguments);
  <span class="pl-k">var</span> that <span class="pl-k">=</span> <span class="pl-v">this</span>;
  <span class="pl-k">return</span> <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> that.<span class="pl-c1">apply</span>(<span class="pl-c1">null</span>, args.<span class="pl-c1">concat</span>(slice.<span class="pl-c1">apply</span>(arguments)));
  };
});</pre></div>

<p>​</p>

<h3>
<a id="simple-example" class="anchor" href="#simple-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Simple example</h3>

<div class="highlight highlight-javascript"><pre><span class="pl-k">function</span> <span class="pl-en">add</span>(<span class="pl-smi">num</span>){
  <span class="pl-k">return</span> num <span class="pl-k">+</span> <span class="pl-c1">2</span>;
}
<span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-c1">add</span>(<span class="pl-c1">8</span>));
<span class="pl-c">// prints 10</span>

<span class="pl-k">function</span> <span class="pl-en">add2</span>(<span class="pl-smi">num</span>){
  num <span class="pl-k">=</span> num <span class="pl-k">+</span> <span class="pl-c1">10</span>;
  <span class="pl-k">return</span> add.<span class="pl-c1">apply</span>(<span class="pl-c1">null</span>, [num]);
}
<span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-c1">add2</span>(<span class="pl-c1">20</span>));
<span class="pl-c">// prints 32</span></pre></div>

<p>​</p>

<h3>
<a id="memoization" class="anchor" href="#memoization" aria-hidden="true"><span class="octicon octicon-link"></span></a>Memoization</h3>

<p>Functions can use objects to remember the results of previous operations, making it possible to avoid unnecessary work. This optimization is called memoization</p>

<h3>
<a id="inheritance" class="anchor" href="#inheritance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Inheritance</h3>

<p>In simple words, an object inherits from that class which is pointed by prototype</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> <span class="pl-en">Parent</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
  <span class="pl-c1">this</span>.<span class="pl-en">method1</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>Parent<span class="pl-pds">"</span></span>);
  }
}

<span class="pl-k">var</span> <span class="pl-en">Child</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
  <span class="pl-c1">this</span>.<span class="pl-en">method2</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-en">console</span><span class="pl-c1">.log</span>(<span class="pl-s"><span class="pl-pds">"</span>Child<span class="pl-pds">"</span></span>);
  }
}

<span class="pl-c1">Child</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Parent</span>();
<span class="pl-k">var</span> c <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Child</span>();
c.<span class="pl-c1">method1</span>();
<span class="pl-c">// prints Parent</span>
c.<span class="pl-c1">method2</span>();
<span class="pl-c">// prints Child  </span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>(c <span class="pl-k">instanceof</span> Parent);
<span class="pl-c">// prints true</span>
<span class="pl-en">console</span><span class="pl-c1">.log</span>(c <span class="pl-k">instanceof</span> Child);
<span class="pl-c">// prints true</span></pre></div>

<p>​
The following code defines/creates a function object. This object has a prototype property which further has a hidden property called constructor. This constructor property points to the function itself which defines the object.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-k">var</span> <span class="pl-en">Child</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
  <span class="pl-v">this</span>.<span class="pl-c1">name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Chanky<span class="pl-pds">"</span></span>;
}
<span class="pl-en">console</span><span class="pl-c1">.log</span>(Child.<span class="pl-c1">prototype</span>);
<span class="pl-c">// prints an empty object as Object{}, although it has a constructor property</span>

<span class="pl-en">console</span><span class="pl-c1">.log</span>(Child.<span class="pl-c1">prototype</span>.<span class="pl-c1">constructor</span>);
<span class="pl-c">// prints the function i.e. function(){this.name="Chanky"}</span></pre></div>

<p>​
Every function gets a prototype object because the language does not provide a way of determining which functions are intended to be used as constructors. The constructor property is not useful. It is the prototype object that is important.</p>

<p>JavaScript, being a loosely typed language, never casts. The lineage of an object is irrelevant. What matters about an object is what it can do, not what it is descended from.</p>

<p>JavaScript is a prototypal language, which means that objects inherit directly from other objects.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-c1">Function</span>.<span class="pl-c1">method</span>(<span class="pl-s"><span class="pl-pds">'</span>inherits<span class="pl-pds">'</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">Parent</span>) {
  <span class="pl-c1">this</span>.<span class="pl-c1">prototype</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Parent</span>( );
  <span class="pl-k">return</span> <span class="pl-v">this</span>;
});</pre></div>

<h3>
<a id="object-specifiers" class="anchor" href="#object-specifiers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object Specifiers</h3>

<p>It sometimes happens that a constructor is given a very large number of parameters. This can be troublesome because it can be very difficult to remember the order of the arguments. In such cases, it can be much friendlier if we write the constructor to accept a single object specifier instead. That object contains the specification of the object to be constructed.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/sumitnsit/javascript">JavaScript</a> is maintained by <a href="https://github.com/sumitnsit">sumitnsit</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
